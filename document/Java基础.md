## Java基础面试题

#### 基础知识

* 什么是原码, 反码, 补码

1. 数据常见的有二进制, 八进制, 十进制, 十六进制等4种表现形式
	* 二进制: 0b100, (0b开头, 0,1两种数值)
	* 八进制: 017, (0开头, 范围 0 ~ 7)
	* 十进制: 98, 默认就是十进制, 范围:0 ~ 9
	* 十六进制: 0xABCDEF, 0x开头, 范围:0 ~ F, 其中A对应10, ..., F对应15
	
2. 二进制具有原码, 反码, 补码三种表现形式
	* int数的原码: 1位符号位 + 31位数值位, 符号位1表示负数, 0表示正数
	* 反码: 原码的数值位取反, 符号位不变, (取反即为0变1, 1变0)
	* 补码: 正数的补码为它本身, 负数的补码为: 反码 + 1
	* 计算机是以补码形式保存数据, 之所以用补码表示数据, 是为了便于直接用补码进行运算;

* 用二进制表示 -4 + 5, -4 + 3的过程
		
		假设-4为byte类型
		-4的原码: 1 000 0100 , 反码: 1 111 1011 , 补码: 1 111 1100
		5的原码: 0 000 0101 , 补码: 0 000 0101
		
		运算时是补码直接相加: 
			-4 : 1 111 1100
			5 : 0 000 0101
			+ -------------
				0 000 0001		// 运算时, 符号位也要进1
				// 运算出来的数符号位是0表示是正数, 数值位值是1, 表示这个数是 + 1
		
		3的原码: 0 000 0011, 补码: 0 000 0011
		
			-4 : 1 111 1100
			3 : 0 000 0011
			+ -------------
				1 111 1111		
				// 运算出来的数符号位是1表示是负数, 1 111 1111转回原码:
				// 1 111 1111 -> -1还原为反码: 1 111 1110 -> 变为原码: 1 000 0001 -> 对应的值是 -1

#### java中==和equals和hashCode的区别

* 使用范围
    * ==：基本数据类型，对象
    * equals和hashCode: 对象

* ==
    * 比较基本数据类型的时候比对的是数值，值相等，为true，否则为false;
    * 比较对象时，比对的是内存地址(内存地址其实也是一种值)，只有当指针指向的是同一个内存时，才为true

* equals
    * 上面的==运算符，只有当比较双方为同一个对象时才会为true; 实际工作中，我们需要在两个对象的某些特性相等时认为
    它们相等，这个需求可以通过重写equals方法来实现，这样即便两个对象指向的内存地址不一样，但是因为他们具有相同的性质，我们也可以认为它们
    "相等"
    * Object的equals实现是this.getClassName()+"@"+hashCode(),因为Object的hashCode值是通过内存地址计算而得，
    所以通常情况下直接调用Object#equals方法判断两个对象是否相等，都会返回false; 不排除有出现hash碰撞的情况，如果出现，equals返回的就是true了，
    * equals方法通常都会重写;

* hashCode()
    * 哈希散列: 用通俗的话说就是一个函数，传入不同的参数，返回值也是不一样且分散的
    * hashCode(): Java对象可以具有多种不同数据类型的成员变量，hashCode()的作用就是将一个对象通过算法序列化成散列int数
    * hashCode的作用, 可以作为对象的地址值，提高查询的效率
        * hashCode & array.length < array.length
    * 典型的使用：HashMap
    * 哈希碰撞：指两个对象，相同属性具有不同的值，但是hashCode相等的情况；这种情况我们要尽力的避免，当出现后也要调用equals
    方法做进一步判断，所以在重写hashCode()方法时一般都重写equals方法
